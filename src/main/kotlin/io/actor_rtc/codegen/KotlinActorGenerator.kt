/**
 * Kotlin Actor Code Generator
 *
 * Generates Handler interface and Dispatcher for ACTR services. Similar to the Rust ModernGenerator
 * but for Kotlin.
 */
package io.actor_rtc.codegen

import com.google.protobuf.DescriptorProtos.MethodDescriptorProto
import com.google.protobuf.compiler.PluginProtos.CodeGeneratorResponse

/** Generator for Kotlin Actor framework code */
class KotlinActorGenerator(
        private val packageName: String,
        private val serviceName: String,
        private val methods: List<MethodDescriptorProto>,
        private val params: Map<String, String>,
        private val protoFileName: String = ""
) {
    /** Generate the actor code file */
    fun generate(): CodeGeneratorResponse.File {
        val kotlinPackage = params["kotlin_package"] ?: "com.example.generated"
        val code = buildString {
            appendLine(generateHeader(kotlinPackage))
            appendLine()
            appendLine(generateImports())
            appendLine()
            appendLine(generateHandlerInterface())
            appendLine()
            appendLine(generateDispatcher())
        }

        val fileName = "${serviceName.toSnakeCase()}_actor.kt"

        return CodeGeneratorResponse.File.newBuilder().setName(fileName).setContent(code).build()
    }

    /** Generate file header */
    private fun generateHeader(kotlinPackage: String): String {
        return """
            |/**
            | * Auto-generated code - DO NOT EDIT
            | *
            | * Generated by protoc-gen-actrframework-kotlin plugin
            | *
            | * Service: $serviceName
            | * Package: $packageName
            | */
            |package $kotlinPackage
        """.trimMargin()
    }

    /** Generate import statements */
    private fun generateImports(): String {
        // Get the outer class name from proto file name
        val outerClassName = getProtoOuterClassName()

        return buildString {
            appendLine("import io.actor_rtc.actr.ContextBridge")
            appendLine("import io.actor_rtc.actr.RpcEnvelopeBridge")
            appendLine()
            // Import the protobuf outer class
            // The outer class name is derived from the proto file name (e.g., file.proto -> File)
            appendLine("// Import protobuf message types")
            appendLine("// These are generated by the protobuf gradle plugin")
            appendLine("import $packageName.$outerClassName.*")
        }
    }

    /** Generate Handler interface */
    private fun generateHandlerInterface(): String {
        val handlerName = "${serviceName}Handler"

        val methodSignatures =
                methods.joinToString("\n\n") { method ->
                    val methodName = method.name.toSnakeCase()
                    val inputType = extractMessageType(method.inputType)
                    val outputType = extractMessageType(method.outputType)

                    """
            |    /**
            |     * RPC method: ${method.name}
            |     */
            |    suspend fun $methodName(request: $inputType, ctx: ContextBridge): $outputType
            """.trimMargin()
                }

        return """
            |/**
            | * Handler interface for $serviceName
            | *
            | * Implement this interface to provide your business logic.
            | *
            | * Example:
            | * ```kotlin
            | * class My$serviceName : $handlerName {
            | *     override suspend fun methodName(request: RequestType, ctx: ContextBridge): ResponseType {
            | *         // Business logic here
            | *         return ResponseType.newBuilder().build()
            | *     }
            | * }
            | * ```
            | */
            |interface $handlerName {
            |$methodSignatures
            |}
        """.trimMargin()
    }

    /** Generate Dispatcher object */
    private fun generateDispatcher(): String {
        val dispatcherName = "${serviceName}Dispatcher"
        val handlerName = "${serviceName}Handler"

        val matchCases =
                methods.joinToString("\n") { method ->
                    val routeKey = "$packageName.$serviceName.${method.name}"
                    val methodName = method.name.toSnakeCase()
                    val inputType = extractMessageType(method.inputType)

                    """
            |            "$routeKey" -> {
            |                val request = $inputType.parseFrom(envelope.payload)
            |                val response = handler.$methodName(request, ctx)
            |                response.toByteArray()
            |            }
            """.trimMargin()
                }

        return """
            |/**
            | * Message dispatcher for $serviceName
            | *
            | * Routes incoming messages to the appropriate handler method.
            | * This is a zero-overhead dispatcher - all routing is done at compile time.
            | */
            |object $dispatcherName {
            |    /**
            |     * Dispatch an RPC envelope to the appropriate handler method
            |     *
            |     * @param handler The handler implementation
            |     * @param ctx The context bridge
            |     * @param envelope The RPC envelope containing the request
            |     * @return The serialized response bytes
            |     */
            |    suspend fun dispatch(
            |        handler: $handlerName,
            |        ctx: ContextBridge,
            |        envelope: RpcEnvelopeBridge
            |    ): ByteArray {
            |        return when (envelope.routeKey) {
            |$matchCases
            |            else -> throw IllegalArgumentException("Unknown route key: ${'$'}{envelope.routeKey}")
            |        }
            |    }
            |}
        """.trimMargin()
    }

    /** Extract message type name from fully qualified proto type */
    private fun extractMessageType(typeName: String): String {
        val cleaned = typeName.trimStart('.')
        return cleaned.split(".").last()
    }

    /**
     * Get proto outer class name from proto file name Convention: proto file name in PascalCase
     * e.g., file.proto -> File, file_transfer.proto -> FileTransfer
     */
    private fun getProtoOuterClassName(): String {
        if (protoFileName.isNotEmpty()) {
            // Remove .proto extension and convert to PascalCase
            val baseName = protoFileName.removeSuffix(".proto")
            return baseName.toPascalCase()
        }
        // Fallback: use package name last part
        return packageName.split(".").last().toPascalCase()
    }

    /** Convert string to snake_case */
    private fun String.toSnakeCase(): String {
        return this.replace(Regex("([a-z])([A-Z])"), "$1_$2").lowercase()
    }

    /** Convert string to PascalCase */
    private fun String.toPascalCase(): String {
        return this.split("_", "-").joinToString("") { word ->
            word.replaceFirstChar { it.uppercase() }
        }
    }
}
